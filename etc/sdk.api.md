## API Report File for "@spacehq/sdk"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { Buckets } from '@textile/hub';
import { Client } from '@textile/hub';
import { IGunChainReference } from 'gun/types/chain';
import Pino from 'pino';
import { UserAuth } from '@textile/hub';

// @public (undocumented)
export interface AddItemFile {
    // (undocumented)
    data: ReadableStream<Uint8Array> | ArrayBuffer | string | Blob;
    mimeType: string;
    path: string;
    progress?: (bytesRead?: number) => void;
}

// @public (undocumented)
export type AddItemsEventData = AddItemsStatus | AddItemsResultSummary;

// @public (undocumented)
export type AddItemsEventType = 'data' | 'error' | 'done';

// @public (undocumented)
export type AddItemsListener = (data: AddItemsEventData) => void;

// @public (undocumented)
export interface AddItemsRequest {
    // (undocumented)
    bucket: string;
    // (undocumented)
    files: AddItemFile[];
}

// @public (undocumented)
export interface AddItemsResponse {
    // (undocumented)
    off: (type: AddItemsEventType, listener: AddItemsListener) => void;
    // (undocumented)
    on: (type: AddItemsEventType, listener: AddItemsListener) => void;
    once: (type: AddItemsEventType, listener: AddItemsListener) => void;
}

// @public (undocumented)
export interface AddItemsResultSummary {
    // (undocumented)
    bucket: string;
    // (undocumented)
    files: AddItemsStatus[];
}

// @public (undocumented)
export interface AddItemsStatus {
    entry?: DirectoryEntry;
    // (undocumented)
    error?: Error;
    // (undocumented)
    path: string;
    // (undocumented)
    status: 'success' | 'error';
}

// @public
export class BrowserStorage {
    constructor();
    // (undocumented)
    add(identity: Identity): Promise<void>;
    // (undocumented)
    list(): Promise<Identity[]>;
    // (undocumented)
    remove(key: string): Promise<void>;
}

// @public
export interface BucketMetadata {
    dbId: string;
    encryptionKey: Uint8Array;
    slug: string;
}

// @public (undocumented)
export interface CreateFolderRequest {
    bucket: string;
    path: string;
}

// @public
export interface DirectoryEntry {
    // (undocumented)
    backupCount: number;
    // (undocumented)
    bucket: string;
    // (undocumented)
    created: string;
    // (undocumented)
    dbId: string;
    // (undocumented)
    fileExtension: string;
    // (undocumented)
    ipfsHash: string;
    // (undocumented)
    isBackupInProgress: boolean;
    // (undocumented)
    isDir: boolean;
    // (undocumented)
    isLocallyAvailable: boolean;
    // (undocumented)
    isRestoreInProgress: boolean;
    // (undocumented)
    items?: DirectoryEntry[];
    // (undocumented)
    members: FileMember[];
    // (undocumented)
    name: string;
    // (undocumented)
    path: string;
    // (undocumented)
    sizeInBytes: number;
    // (undocumented)
    updated: string;
    // (undocumented)
    uuid: string;
}

// @public (undocumented)
export class DirEntryNotFoundError extends Error {
    constructor(filePath: string, bucket: string);
}

// @public
export interface FileMember {
    // (undocumented)
    address?: string;
    // (undocumented)
    publicKey: string;
}

// @public
export interface FileMetadata {
    // (undocumented)
    bucketKey?: string;
    // (undocumented)
    bucketSlug: string;
    // (undocumented)
    dbId: string;
    // (undocumented)
    mimeType?: string;
    // (undocumented)
    path: string;
    // (undocumented)
    uuid?: string;
}

// @public (undocumented)
export class FileNotFoundError extends Error {
    constructor();
}

// @public
export class FileStorage {
    constructor(filename: string);
    // (undocumented)
    add(identity: Identity): Promise<void>;
    // (undocumented)
    list(): Promise<Identity[]>;
    // (undocumented)
    remove(key: string): Promise<void>;
    }

// @public (undocumented)
export const GetAddressFromPublicKey: (pubkey: string) => string;

// @public
export class GundbMetadataStore implements UserMetadataStore {
    createBucket(bucketSlug: string, dbId: string): Promise<BucketMetadata>;
    findBucket(bucketSlug: string): Promise<BucketMetadata | undefined>;
    findFileMetadata(bucketSlug: string, dbId: string, path: string): Promise<FileMetadata | undefined>;
    findFileMetadataByUuid(uuid: string): Promise<FileMetadata | undefined>;
    // Warning: (ae-forgotten-export) The symbol "GunInit" needs to be exported by the entry point index.d.ts
    static fromIdentity(username: string, userpass: string, gunOrServer?: GunInit | string | string[], logger?: Pino.Logger | boolean): Promise<GundbMetadataStore>;
    listBuckets(): Promise<BucketMetadata[]>;
    setFilePublic(metadata: FileMetadata): Promise<void>;
    upsertFileMetadata(metadata: FileMetadata): Promise<FileMetadata>;
    }

// Warning: (ae-internal-missing-underscore) The name "HubAuthResponse" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal
export interface HubAuthResponse {
    // (undocumented)
    storageAuth?: TextileStorageAuth;
    // (undocumented)
    token: string;
}

// @public
export interface Identity {
    privKey: Uint8Array;
    public: Public;
    sign(data: Uint8Array): Promise<Uint8Array>;
}

// @public
export interface IdentityStorage {
    // (undocumented)
    add: (identity: Identity) => Promise<void>;
    // (undocumented)
    list: () => Promise<Identity[]>;
    // (undocumented)
    remove: (key: string) => Promise<void>;
}

// @public (undocumented)
export interface ListDirectoryRequest {
    bucket: string;
    path: string;
    recursive?: boolean;
}

// @public (undocumented)
export interface ListDirectoryResponse {
    // (undocumented)
    items: DirectoryEntry[];
}

// @public (undocumented)
export interface MakeFilePublicRequest {
    allowAccess: boolean;
    // (undocumented)
    bucket: string;
    // (undocumented)
    path: string;
}

// @public (undocumented)
export interface OpenFileRequest {
    // (undocumented)
    bucket: string;
    // (undocumented)
    path: string;
    progress?: (bytesRead?: number) => void;
}

// @public (undocumented)
export interface OpenFileResponse {
    consumeStream: () => Promise<Uint8Array>;
    // (undocumented)
    mimeType: string | undefined;
    // (undocumented)
    stream: AsyncIterableIterator<Uint8Array>;
}

// @public (undocumented)
export interface OpenUuidFileRequest {
    progress?: (bytesRead?: number) => void;
    // (undocumented)
    uuid: string;
}

// @public (undocumented)
export interface OpenUuidFileResponse {
    consumeStream: () => Promise<Uint8Array>;
    entry: DirectoryEntry;
    // (undocumented)
    mimeType: string | undefined;
    // (undocumented)
    stream: AsyncIterableIterator<Uint8Array>;
}

// @public
export interface Public {
    bytes: Uint8Array;
    pubKey: Uint8Array;
    verify(data: Uint8Array, sig: Uint8Array): Promise<boolean>;
}

// @public
export interface SpaceUser {
    // (undocumented)
    identity: Identity;
    // (undocumented)
    storageAuth?: TextileStorageAuth;
    token: string;
}

// @public
export class SpaceVaultService implements Vault {
    constructor(config: VaultServiceConfig);
    // (undocumented)
    retrieve(uuid: string, passphrase: string, backupType: VaultBackupType): Promise<VaultItem[]>;
    store(uuid: string, passphrase: string, backupType: VaultBackupType, items: VaultItem[], metadata: Record<string, string>): Promise<void>;
}

// @public (undocumented)
export interface TextileStorageAuth {
    // (undocumented)
    key: string;
    // (undocumented)
    msg: string;
    // (undocumented)
    sig: string;
    // (undocumented)
    token: string;
}

// @public (undocumented)
export interface TxlSubscribeBucketEvent {
    // (undocumented)
    bucketName: string;
    // (undocumented)
    error?: Error;
    // (undocumented)
    status: 'success' | 'error';
}

// @public (undocumented)
export type TxlSubscribeEventData = TxlSubscribeBucketEvent;

// @public (undocumented)
export type TxlSubscribeEventType = 'data' | 'error' | 'done';

// @public (undocumented)
export type TxlSubscribeListener = (data: TxlSubscribeEventData) => void;

// @public (undocumented)
export interface TxlSubscribeResponse {
    // (undocumented)
    off: (type: TxlSubscribeEventType, listener: TxlSubscribeListener) => void;
    // (undocumented)
    on: (type: TxlSubscribeEventType, listener: TxlSubscribeListener) => void;
    once: (type: TxlSubscribeEventType, listener: TxlSubscribeListener) => void;
}

// @public (undocumented)
export class UnauthenticatedError extends Error {
    constructor();
}

// @public
export interface UserMetadataStore {
    createBucket: (bucketSlug: string, dbId: string) => Promise<BucketMetadata>;
    findBucket: (bucketSlug: string) => Promise<BucketMetadata | undefined>;
    findFileMetadata: (bucketSlug: string, dbId: string, path: string) => Promise<FileMetadata | undefined>;
    findFileMetadataByUuid: (uuid: string) => Promise<FileMetadata | undefined>;
    listBuckets: () => Promise<BucketMetadata[]>;
    setFilePublic: (metadata: FileMetadata) => Promise<void>;
    upsertFileMetadata: (data: FileMetadata) => Promise<FileMetadata>;
}

// @public
export class Users {
    constructor(config: UsersConfig, storage?: IdentityStorage);
    authenticate(identity: Identity): Promise<SpaceUser>;
    backupKeysByPassphrase(uuid: string, passphrase: string, backupType: VaultBackupType, identity: Identity): Promise<void>;
    createIdentity(): Promise<Identity>;
    list(): SpaceUser[];
    recoverKeysByPassphrase(uuid: string, passphrase: string, backupType: VaultBackupType): Promise<SpaceUser>;
    remove(publicKey: string): Promise<void>;
    static withStorage(storage: IdentityStorage, config: UsersConfig, onError?: CallableFunction): Promise<Users>;
}

// @public
export interface UsersConfig {
    // Warning: (ae-incompatible-release-tags) The symbol "authChallengeSolver" is marked as @public, but its signature references "HubAuthResponse" which is marked as @internal
    //
    // (undocumented)
    authChallengeSolver?: (identity: Identity) => Promise<HubAuthResponse>;
    endpoint: string;
    vaultInit?: () => Vault;
    vaultServiceConfig?: VaultServiceConfig;
}

// @public
export class UserStorage {
    constructor(user: SpaceUser, config?: UserStorageConfig);
    addItems(request: AddItemsRequest): Promise<AddItemsResponse>;
    createFolder(request: CreateFolderRequest): Promise<void>;
    initListener(): Promise<void>;
    listDirectory(request: ListDirectoryRequest): Promise<ListDirectoryResponse>;
    openFile(request: OpenFileRequest): Promise<OpenFileResponse>;
    openFileByUuid(request: OpenUuidFileRequest): Promise<OpenUuidFileResponse>;
    setFilePublicAccess(request: MakeFilePublicRequest): Promise<void>;
    txlSubscribe(): Promise<TxlSubscribeResponse>;
    }

// @public (undocumented)
export interface UserStorageConfig {
    bucketsInit?: (auth: UserAuth) => Buckets;
    debugMode?: boolean;
    // (undocumented)
    metadataStoreInit?: (identity: Identity) => Promise<UserMetadataStore>;
    // (undocumented)
    textileHubAddress?: string;
    // (undocumented)
    threadsInit?: (auth: UserAuth) => Client;
}

// @public
export interface Vault {
    retrieve: (uuid: string, passphrase: string, backupType: VaultBackupType) => Promise<VaultItem[]>;
    store: (uuid: string, passphrase: string, backupType: VaultBackupType, item: VaultItem[], metadata: Record<string, string>) => Promise<void>;
}

// @public (undocumented)
export enum VaultBackupType {
    // (undocumented)
    Email = "email",
    // (undocumented)
    Google = "google",
    // (undocumented)
    Twitter = "twitter"
}

// @public
export interface VaultItem {
    // (undocumented)
    itemType: VaultItemType;
    // (undocumented)
    value: string;
}

// @public (undocumented)
export enum VaultItemType {
    // (undocumented)
    PrivateKeyWithMnemonic = "PrivateKeyWithMnemonic"
}

// @public (undocumented)
export interface VaultServiceConfig {
    // (undocumented)
    saltSecret: string;
    // (undocumented)
    serviceUrl: string;
}

// @public (undocumented)
export enum VkVersion {
    // (undocumented)
    VkVersion1 = "V1"
}


// (No @packageDocumentation comment for this package)

```
