## API Report File for "@spacehq/sdk"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { Buckets } from '@textile/hub';
import { Client } from '@textile/hub';
import { IGunChainReference } from 'gun/types/chain';
import { PathAccessRole } from '@textile/hub';
import Pino from 'pino';
import { UserAuth } from '@textile/hub';

// @public (undocumented)
export interface AcceptInvitationResponse {
    // (undocumented)
    files: SharedWithMeFiles[];
}

// @public (undocumented)
export interface AddItemFile {
    // (undocumented)
    data: ReadableStream<Uint8Array> | ArrayBuffer | string | Blob;
    mimeType: string;
    path: string;
    progress?: (bytesRead?: number) => void;
}

// @public (undocumented)
export type AddItemsEventData = AddItemsStatus | AddItemsResultSummary;

// @public (undocumented)
export type AddItemsEventType = 'data' | 'error' | 'done';

// @public (undocumented)
export type AddItemsListener = (data: AddItemsEventData) => void;

// @public (undocumented)
export interface AddItemsRequest {
    // (undocumented)
    bucket: string;
    // (undocumented)
    files: AddItemFile[];
}

// @public (undocumented)
export interface AddItemsResponse {
    // (undocumented)
    off: (type: AddItemsEventType, listener: AddItemsListener) => void;
    // (undocumented)
    on: (type: AddItemsEventType, listener: AddItemsListener) => void;
    once: (type: AddItemsEventType, listener: AddItemsListener) => void;
}

// @public (undocumented)
export interface AddItemsResultSummary {
    // (undocumented)
    bucket: string;
    // (undocumented)
    files: AddItemsStatus[];
}

// @public (undocumented)
export interface AddItemsStatus {
    entry?: DirectoryEntry;
    // (undocumented)
    error?: Error;
    // (undocumented)
    path: string;
    // (undocumented)
    status: 'success' | 'error';
}

// @public
export class BrowserStorage {
    constructor();
    // (undocumented)
    add(identity: Identity): Promise<void>;
    // (undocumented)
    list(): Promise<Identity[]>;
    // (undocumented)
    remove(key: string): Promise<void>;
}

// @public
export interface BucketMetadata {
    bucketKey: string;
    dbId: string;
    encryptionKey: Uint8Array;
    slug: string;
}

// @public (undocumented)
export interface CreateFolderRequest {
    bucket: string;
    path: string;
}

// @public
export interface DirectoryEntry {
    // (undocumented)
    backupCount: number;
    // (undocumented)
    bucket: string;
    // (undocumented)
    created: string;
    // (undocumented)
    dbId: string;
    // (undocumented)
    fileExtension: string;
    // (undocumented)
    ipfsHash: string;
    // (undocumented)
    isBackupInProgress: boolean;
    // (undocumented)
    isDir: boolean;
    // (undocumented)
    isLocallyAvailable: boolean;
    // (undocumented)
    isRestoreInProgress: boolean;
    // (undocumented)
    items?: DirectoryEntry[];
    // (undocumented)
    members: FileMember[];
    // (undocumented)
    name: string;
    // (undocumented)
    path: string;
    // (undocumented)
    sizeInBytes: number;
    // (undocumented)
    updated: string;
    // (undocumented)
    uuid: string;
}

// @public (undocumented)
export class DirEntryNotFoundError extends Error {
    constructor(filePath: string, bucket: string);
}

// @public
export interface FileMember {
    // (undocumented)
    address?: string;
    // (undocumented)
    publicKey: string;
    // (undocumented)
    role: PathAccessRole;
}

// @public
export interface FileMetadata {
    // (undocumented)
    bucketKey?: string;
    // (undocumented)
    bucketSlug: string;
    // (undocumented)
    dbId: string;
    // (undocumented)
    mimeType?: string;
    // (undocumented)
    path: string;
    // (undocumented)
    uuid?: string;
}

// @public (undocumented)
export class FileNotFoundError extends Error {
    constructor();
}

// @public
export class FileStorage {
    constructor(filename: string);
    // (undocumented)
    add(identity: Identity): Promise<void>;
    // (undocumented)
    list(): Promise<Identity[]>;
    // (undocumented)
    remove(key: string): Promise<void>;
    }

// @public
export interface FullPath {
    // (undocumented)
    bucket: string;
    // (undocumented)
    bucketKey?: string;
    // (undocumented)
    dbId?: string;
    // (undocumented)
    path: string;
}

// @public (undocumented)
export const GetAddressFromPublicKey: (pubkey: string) => string;

// @public (undocumented)
export interface GetFilesSharedByMeResponse {
    // (undocumented)
    files: SharedWithMeFiles[];
    // (undocumented)
    nextOffset?: string;
}

// @public (undocumented)
export interface GetFilesSharedWithMeResponse {
    // (undocumented)
    files: SharedWithMeFiles[];
    // (undocumented)
    nextOffset?: string;
}

// @public (undocumented)
export interface GetNotificationsResponse {
    // (undocumented)
    lastSeenAt: number;
    // (undocumented)
    nextOffset: string;
    // (undocumented)
    notifications: Notification_2[];
}

// @public (undocumented)
export interface GetRecentlySharedWithResponse {
    // (undocumented)
    members: FileMember[];
    // (undocumented)
    nextOffset?: string;
}

// @public
export class GundbMetadataStore implements UserMetadataStore {
    addUserRecentlySharedWith(user: ShareUserMetadata): Promise<ShareUserMetadata>;
    createBucket(bucketSlug: string, dbId: string, bucketKey: string): Promise<BucketMetadata>;
    findBucket(bucketSlug: string): Promise<BucketMetadata | undefined>;
    findFileMetadata(bucketSlug: string, dbId: string, path: string): Promise<FileMetadata | undefined>;
    findFileMetadataByUuid(uuid: string): Promise<FileMetadata | undefined>;
    findSharedFilesByInvitation(invitationId: string): Promise<SharedFileMetadata | undefined>;
    // Warning: (ae-forgotten-export) The symbol "GunInit" needs to be exported by the entry point index.d.ts
    static fromIdentity(username: string, userpass: string, gunOrServer?: GunInit | string | string[], logger?: Pino.Logger | boolean): Promise<GundbMetadataStore>;
    getNotificationsLastSeenAt(): Promise<number>;
    listBuckets(): Promise<BucketMetadata[]>;
    listSharedByMeFiles(): Promise<SharedFileMetadata[]>;
    listSharedWithMeFiles(): Promise<SharedFileMetadata[]>;
    listUsersRecentlySharedWith(): Promise<ShareUserMetadata[]>;
    setFilePublic(metadata: FileMetadata): Promise<void>;
    setNotificationsLastSeenAt(timestamp: number): Promise<void>;
    upsertFileMetadata(metadata: FileMetadata): Promise<FileMetadata>;
    upsertSharedByMeFile(fileData: SharedFileMetadata): Promise<SharedFileMetadata>;
    upsertSharedWithMeFile(fileData: SharedFileMetadata): Promise<SharedFileMetadata>;
    }

// Warning: (ae-internal-missing-underscore) The name "HubAuthResponse" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal
export interface HubAuthResponse {
    // (undocumented)
    storageAuth?: TextileStorageAuth;
    // (undocumented)
    token: string;
}

// @public
export interface Identity {
    privKey: Uint8Array;
    public: Public;
    sign(data: Uint8Array): Promise<Uint8Array>;
}

// @public
export interface IdentityStorage {
    // (undocumented)
    add: (identity: Identity) => Promise<void>;
    // (undocumented)
    list: () => Promise<Identity[]>;
    // (undocumented)
    remove: (key: string) => Promise<void>;
}

// @public
export interface Invitation {
    // (undocumented)
    invitationID?: string;
    // (undocumented)
    inviteePublicKey: string;
    // (undocumented)
    inviterPublicKey: string;
    // (undocumented)
    itemPaths: FullPath[];
    // (undocumented)
    keys: Uint8Array[];
    // (undocumented)
    status: InvitationStatus;
}

// @public
export enum InvitationStatus {
    // (undocumented)
    ACCEPTED = 1,
    // (undocumented)
    PENDING = 0,
    // (undocumented)
    REJECTED = 2
}

// @public (undocumented)
export interface ListDirectoryRequest {
    bucket: string;
    path: string;
    recursive?: boolean;
}

// @public (undocumented)
export interface ListDirectoryResponse {
    // (undocumented)
    items: DirectoryEntry[];
}

// @public (undocumented)
export interface MakeFilePublicRequest {
    allowAccess: boolean;
    // (undocumented)
    bucket: string;
    // (undocumented)
    path: string;
}

// @public (undocumented)
interface Notification_2 {
    // (undocumented)
    body: Uint8Array;
    // (undocumented)
    createdAt: number;
    // (undocumented)
    decryptedBody: Uint8Array;
    // (undocumented)
    from: string;
    // (undocumented)
    id: string;
    // (undocumented)
    readAt?: number;
    // (undocumented)
    relatedObject?: Invitation;
    // (undocumented)
    to: string;
    // (undocumented)
    type: NotificationType;
}

export { Notification_2 as Notification }

// @public (undocumented)
export interface NotificationSubscribeEvent {
    // (undocumented)
    error?: Error;
    // (undocumented)
    notification: Notification_2;
    // (undocumented)
    status: 'success' | 'error';
}

// @public (undocumented)
export type NotificationSubscribeEventData = NotificationSubscribeEvent;

// @public (undocumented)
export type NotificationSubscribeEventType = 'data' | 'error' | 'done';

// @public (undocumented)
export type NotificationSubscribeListener = (data: NotificationSubscribeEventData) => void;

// @public (undocumented)
export interface NotificationSubscribeResponse {
    // (undocumented)
    off: (type: NotificationSubscribeEventType, listener: NotificationSubscribeListener) => void;
    // (undocumented)
    on: (type: NotificationSubscribeEventType, listener: NotificationSubscribeListener) => void;
    once: (type: NotificationSubscribeEventType, listener: NotificationSubscribeListener) => void;
}

// @public (undocumented)
export enum NotificationType {
    // (undocumented)
    INVITATION = 1,
    // (undocumented)
    INVITATION_REPLY = 3,
    // (undocumented)
    REVOKED_INVITATION = 4,
    // (undocumented)
    UNKNOWN = 0,
    // (undocumented)
    USAGEALERT = 2
}

// @public (undocumented)
export interface OpenFileRequest {
    // (undocumented)
    bucket: string;
    // (undocumented)
    path: string;
    progress?: (bytesRead?: number) => void;
}

// @public (undocumented)
export interface OpenFileResponse {
    consumeStream: () => Promise<Uint8Array>;
    // (undocumented)
    mimeType: string | undefined;
    // (undocumented)
    stream: AsyncIterableIterator<Uint8Array>;
}

// @public (undocumented)
export interface OpenUuidFileRequest {
    progress?: (bytesRead?: number) => void;
    // (undocumented)
    uuid: string;
}

// @public (undocumented)
export interface OpenUuidFileResponse {
    consumeStream: () => Promise<Uint8Array>;
    entry: DirectoryEntry;
    // (undocumented)
    mimeType: string | undefined;
    // (undocumented)
    stream: AsyncIterableIterator<Uint8Array>;
}

// @public
export interface Public {
    bytes: Uint8Array;
    pubKey: Uint8Array;
    verify(data: Uint8Array, sig: Uint8Array): Promise<boolean>;
}

// @public
export interface SharedFileMetadata extends FileMetadata {
    accepted?: boolean;
    invitationId?: string;
    sharedBy: string;
}

// @public
export interface SharedWithMeFiles {
    // (undocumented)
    entry: DirectoryEntry;
    sharedBy: string;
}

// @public (undocumented)
export enum ShareKeyType {
    // (undocumented)
    Existing = "existing",
    // (undocumented)
    Temp = "temp"
}

// @public
export interface SharePublicKeyInput {
    id: string;
    pk?: string;
}

// @public
export interface SharePublicKeyOutput {
    id: string;
    pk: string;
    tempKey?: string;
    type: ShareKeyType;
}

// @public (undocumented)
export interface ShareUserMetadata {
    // (undocumented)
    publicKey: string;
    // (undocumented)
    role: number;
}

// @public (undocumented)
export interface ShareViaPublicKeyRequest {
    // (undocumented)
    paths: FullPath[];
    publicKeys: SharePublicKeyInput[];
}

// @public (undocumented)
export interface ShareViaPublicKeyResponse {
    // (undocumented)
    publicKeys: SharePublicKeyOutput[];
}

// @public
export interface SpaceUser {
    // (undocumented)
    identity: Identity;
    // (undocumented)
    storageAuth?: TextileStorageAuth;
    token: string;
}

// @public
export class SpaceVaultService implements Vault {
    constructor(config: VaultServiceConfig);
    // (undocumented)
    retrieve(uuid: string, passphrase: string, backupType: VaultBackupType): Promise<VaultItem[]>;
    store(uuid: string, passphrase: string, backupType: VaultBackupType, items: VaultItem[], metadata: Record<string, string>): Promise<void>;
}

// @public (undocumented)
export interface TextileStorageAuth {
    // (undocumented)
    key: string;
    // (undocumented)
    msg: string;
    // (undocumented)
    sig: string;
    // (undocumented)
    token: string;
}

// @public (undocumented)
export interface TxlSubscribeBucketEvent {
    // (undocumented)
    bucketName: string;
    // (undocumented)
    error?: Error;
    // (undocumented)
    status: 'success' | 'error';
}

// @public (undocumented)
export type TxlSubscribeEventData = TxlSubscribeBucketEvent;

// @public (undocumented)
export type TxlSubscribeEventType = 'data' | 'error' | 'done';

// @public (undocumented)
export type TxlSubscribeListener = (data: TxlSubscribeEventData) => void;

// @public (undocumented)
export interface TxlSubscribeResponse {
    // (undocumented)
    off: (type: TxlSubscribeEventType, listener: TxlSubscribeListener) => void;
    // (undocumented)
    on: (type: TxlSubscribeEventType, listener: TxlSubscribeListener) => void;
    once: (type: TxlSubscribeEventType, listener: TxlSubscribeListener) => void;
}

// @public (undocumented)
export class UnauthenticatedError extends Error {
    constructor();
}

// @public
export interface UserMetadataStore {
    addUserRecentlySharedWith(user: ShareUserMetadata): Promise<ShareUserMetadata>;
    createBucket: (bucketSlug: string, dbId: string, bucketKey: string) => Promise<BucketMetadata>;
    findBucket: (bucketSlug: string) => Promise<BucketMetadata | undefined>;
    findFileMetadata: (bucketSlug: string, dbId: string, path: string) => Promise<FileMetadata | undefined>;
    findFileMetadataByUuid: (uuid: string) => Promise<FileMetadata | undefined>;
    findSharedFilesByInvitation: (invitationId: string) => Promise<SharedFileMetadata | undefined>;
    getNotificationsLastSeenAt(): Promise<number>;
    listBuckets: () => Promise<BucketMetadata[]>;
    listSharedByMeFiles(): Promise<SharedFileMetadata[]>;
    listSharedWithMeFiles: () => Promise<SharedFileMetadata[]>;
    listUsersRecentlySharedWith(): Promise<ShareUserMetadata[]>;
    setFilePublic: (metadata: FileMetadata) => Promise<void>;
    setNotificationsLastSeenAt(timestamp: number): Promise<void>;
    upsertFileMetadata: (data: FileMetadata) => Promise<FileMetadata>;
    upsertSharedByMeFile: (data: SharedFileMetadata) => Promise<SharedFileMetadata>;
    upsertSharedWithMeFile: (data: SharedFileMetadata) => Promise<SharedFileMetadata>;
}

// @public
export class Users {
    constructor(config: UsersConfig, storage?: IdentityStorage);
    authenticate(identity: Identity): Promise<SpaceUser>;
    backupKeysByPassphrase(uuid: string, passphrase: string, backupType: VaultBackupType, identity: Identity): Promise<void>;
    createIdentity(): Promise<Identity>;
    list(): SpaceUser[];
    recoverKeysByPassphrase(uuid: string, passphrase: string, backupType: VaultBackupType): Promise<SpaceUser>;
    remove(publicKey: string): Promise<void>;
    static withStorage(storage: IdentityStorage, config: UsersConfig, onError?: CallableFunction): Promise<Users>;
}

// @public
export interface UsersConfig {
    // Warning: (ae-incompatible-release-tags) The symbol "authChallengeSolver" is marked as @public, but its signature references "HubAuthResponse" which is marked as @internal
    //
    // (undocumented)
    authChallengeSolver?: (identity: Identity) => Promise<HubAuthResponse>;
    endpoint: string;
    vaultInit?: () => Vault;
    vaultServiceConfig?: VaultServiceConfig;
}

// @public
export class UserStorage {
    constructor(user: SpaceUser, config?: UserStorageConfig);
    addItems(request: AddItemsRequest): Promise<AddItemsResponse>;
    createFolder(request: CreateFolderRequest): Promise<void>;
    getFilesSharedByMe(offset?: string): Promise<GetFilesSharedByMeResponse>;
    getFilesSharedWithMe(offset?: string): Promise<GetFilesSharedWithMeResponse>;
    getNotifications(seek?: string, limit?: number): Promise<GetNotificationsResponse>;
    getRecentlySharedWith(offset?: string): Promise<GetRecentlySharedWithResponse>;
    // (undocumented)
    handleFileInvitation(invitationId: string, accept: boolean): Promise<AcceptInvitationResponse | undefined>;
    initListener(): Promise<void>;
    initMailbox(): Promise<void>;
    listDirectory(request: ListDirectoryRequest): Promise<ListDirectoryResponse>;
    notificationSubscribe(): Promise<NotificationSubscribeResponse>;
    openFile(request: OpenFileRequest): Promise<OpenFileResponse>;
    openFileByUuid(request: OpenUuidFileRequest): Promise<OpenUuidFileResponse>;
    setFilePublicAccess(request: MakeFilePublicRequest): Promise<void>;
    setNotificationsLastSeenAt(timestamp: number): Promise<void>;
    shareViaPublicKey(request: ShareViaPublicKeyRequest): Promise<ShareViaPublicKeyResponse>;
    static syncFromTempKey(key: string): Promise<void>;
    txlSubscribe(): Promise<TxlSubscribeResponse>;
    }

// @public (undocumented)
export interface UserStorageConfig {
    bucketsInit?: (auth: UserAuth) => Buckets;
    debugMode?: boolean;
    // (undocumented)
    metadataStoreInit?: (identity: Identity) => Promise<UserMetadataStore>;
    // (undocumented)
    textileHubAddress?: string;
    // (undocumented)
    threadsInit?: (auth: UserAuth) => Client;
}

// @public (undocumented)
export class ValidationError extends Error {
    constructor(field: string, message: string);
    }

// @public
export interface Vault {
    retrieve: (uuid: string, passphrase: string, backupType: VaultBackupType) => Promise<VaultItem[]>;
    store: (uuid: string, passphrase: string, backupType: VaultBackupType, item: VaultItem[], metadata: Record<string, string>) => Promise<void>;
}

// @public (undocumented)
export enum VaultBackupType {
    // (undocumented)
    Email = "email",
    // (undocumented)
    Google = "google",
    // (undocumented)
    Twitter = "twitter"
}

// @public
export interface VaultItem {
    // (undocumented)
    itemType: VaultItemType;
    // (undocumented)
    value: string;
}

// @public (undocumented)
export enum VaultItemType {
    // (undocumented)
    PrivateKeyWithMnemonic = "PrivateKeyWithMnemonic"
}

// @public (undocumented)
export interface VaultServiceConfig {
    // (undocumented)
    saltSecret: string;
    // (undocumented)
    serviceUrl: string;
}

// @public (undocumented)
export enum VkVersion {
    // (undocumented)
    VkVersion1 = "V1"
}


export * from "@spacehq/mailbox";
export * from "@spacehq/utils";

// (No @packageDocumentation comment for this package)

```
